
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>appbuilder: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/baidubce/app-builder/go/appbuilder/appbuilder/agent_builder.go (79.8%)</option>
				
				<option value="file1">github.com/baidubce/app-builder/go/appbuilder/appbuilder/agent_builder_data.go (54.1%)</option>
				
				<option value="file2">github.com/baidubce/app-builder/go/appbuilder/appbuilder/app_builder_client.go (80.0%)</option>
				
				<option value="file3">github.com/baidubce/app-builder/go/appbuilder/appbuilder/app_builder_client_data.go (81.1%)</option>
				
				<option value="file4">github.com/baidubce/app-builder/go/appbuilder/appbuilder/config.go (86.1%)</option>
				
				<option value="file5">github.com/baidubce/app-builder/go/appbuilder/appbuilder/dataset.go (74.7%)</option>
				
				<option value="file6">github.com/baidubce/app-builder/go/appbuilder/appbuilder/knowledge_base.go (81.2%)</option>
				
				<option value="file7">github.com/baidubce/app-builder/go/appbuilder/appbuilder/rag.go (0.0%)</option>
				
				<option value="file8">github.com/baidubce/app-builder/go/appbuilder/appbuilder/rag_data.go (0.0%)</option>
				
				<option value="file9">github.com/baidubce/app-builder/go/appbuilder/appbuilder/util.go (70.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright (c) 2024 Baidu, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package appbuilder

import (
        "bufio"
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "mime/multipart"
        "net/http"
        "os"
        "path/filepath"
        "time"
)

// Deprecated: 请使用AppBuilderClient 代替 AgentBuilder
func NewAgentBuilder(appID string, config *SDKConfig) (*AgentBuilder, error) <span class="cov8" title="1">{
        if len(appID) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("appID is empty")
        }</span>
        <span class="cov8" title="1">if config == nil </span><span class="cov0" title="0">{
                return nil, errors.New("config is nil")
        }</span>
        <span class="cov8" title="1">client := config.HTTPClient
        if client == nil </span><span class="cov8" title="1">{
                client = &amp;http.Client{Timeout: 300 * time.Second}
        }</span>
        <span class="cov8" title="1">return &amp;AgentBuilder{appID: appID, sdkConfig: config, client: client}, nil</span>
}

type AgentBuilder struct {
        appID     string
        sdkConfig *SDKConfig
        client    HTTPClient
}

func (t *AgentBuilder) CreateConversation() (string, error) <span class="cov8" title="1">{
        request := http.Request{}
        header := t.sdkConfig.AuthHeaderV2()
        serviceURL, err := t.sdkConfig.ServiceURLV2("/app/conversation")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">request.URL = serviceURL
        request.Method = "POST"
        header.Set("Content-Type", "application/json")
        request.Header = header
        req := map[string]string{"app_id": t.appID}
        data, _ := json.Marshal(req)
        request.Body = NopCloser(bytes.NewReader(data))
        t.sdkConfig.BuildCurlCommand(&amp;request)
        resp, err := t.client.Do(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        requestID, err := checkHTTPResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov8" title="1">data, err = io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov8" title="1">rsp := make(map[string]any)
        if err := json.Unmarshal(data, &amp;rsp); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov8" title="1">val, ok := rsp["conversation_id"]
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("requestID=%s, body=%s", requestID, string(data))
        }</span>
        <span class="cov8" title="1">return val.(string), nil</span>
}

func (t *AgentBuilder) UploadLocalFile(conversationID string, filePath string) (string, error) <span class="cov8" title="1">{
        var data bytes.Buffer
        w := multipart.NewWriter(&amp;data)
        appIDPart, _ := w.CreateFormField("app_id")
        appIDPart.Write([]byte(t.appID))
        conversationIDPart, _ := w.CreateFormField("conversation_id")
        conversationIDPart.Write([]byte(conversationID))
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        filePart, _ := w.CreateFormFile("file", filepath.Base(filePath))
        if _, err := io.Copy(filePart, file); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">w.Close()
        request := http.Request{}
        serviceURL, err := t.sdkConfig.ServiceURLV2("/app/conversation/file/upload")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">request.URL = serviceURL
        request.Method = "POST"
        header := t.sdkConfig.AuthHeaderV2()
        header.Set("Content-Type", w.FormDataContentType())
        request.Header = header
        request.Body = NopCloser(bytes.NewReader(data.Bytes()))
        resp, err := t.client.Do(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        requestID, err := checkHTTPResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov8" title="1">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov8" title="1">rsp := make(map[string]any)
        if err := json.Unmarshal(body, &amp;rsp); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov8" title="1">val, ok := rsp["id"]
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("requestID=%s, body=%s", requestID, string(body))
        }</span>
        <span class="cov8" title="1">return val.(string), nil</span>
}

func (t *AgentBuilder) Run(conversationID string, query string, fileIDS []string, stream bool) (AgentBuilderIterator, error) <span class="cov8" title="1">{
        if len(conversationID) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("conversationID mustn't be empty")
        }</span>
        <span class="cov8" title="1">m := map[string]any{"app_id": t.appID,
                "conversation_id": conversationID,
                "query":           query,
                "file_ids":        fileIDS,
                "stream":          stream,
        }
        request := http.Request{}

        serviceURL, err := t.sdkConfig.ServiceURLV2("/app/conversation/runs")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">request.URL = serviceURL
        request.Method = "POST"
        header := t.sdkConfig.AuthHeaderV2()
        header.Set("Content-Type", "application/json")
        request.Header = header
        data, _ := json.Marshal(m)
        request.Body = NopCloser(bytes.NewReader(data))
        t.sdkConfig.BuildCurlCommand(&amp;request)
        resp, err := t.client.Do(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">requestID, err := checkHTTPResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov8" title="1">r := NewSSEReader(1024*1024, bufio.NewReader(resp.Body))
        if stream </span><span class="cov8" title="1">{
                return &amp;AgentBuilderStreamIterator{requestID: requestID, r: r, body: resp.Body}, nil
        }</span>
        <span class="cov0" title="0">return &amp;AgentBuilderOnceIterator{body: resp.Body}, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright (c) 2024 Baidu, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package appbuilder

import (
        "encoding/json"
        "fmt"
        "io"
        "reflect"
        "strings"
)

func (t *AgentBuilderAnswer) transform(inp *AgentBuilderRawResponse) <span class="cov10" title="127">{
        t.Answer = inp.Answer
        for _, c := range inp.Content </span><span class="cov10" title="127">{
                ev := Event{Code: c.EventCode,
                        Message:     c.EventMessage,
                        Status:      c.EventStatus,
                        EventType:   c.EventType,
                        ContentType: c.ContentType,
                        Detail:      c.Outputs}
                tp, ok := TypeToStruct[ev.ContentType]
                if !ok </span><span class="cov0" title="0">{
                        tp = reflect.TypeOf(DefaultDetail{})
                }</span>
                <span class="cov10" title="127">v := reflect.New(tp)
                _ = json.Unmarshal(c.Outputs, v.Interface())
                ev.Detail = v.Elem().Interface()
                t.Events = append(t.Events, ev)</span>
        }
}

// AgentBuilderIterator 定义AgentBuilder流式/非流式迭代器接口
// 初始状态可迭代,如果返回error不为空则代表迭代结束，
// error为io.EOF，则代表迭代正常结束，其它则为异常结束
type AgentBuilderIterator interface {
        // Next 获取处理结果，如果返回error不为空，迭代器自动失效，不允许再调用此方法
        Next() (*AgentBuilderAnswer, error)
}

type AgentBuilderStreamIterator struct {
        requestID string
        r         *sseReader
        body      io.ReadCloser
}

func (t *AgentBuilderStreamIterator) Next() (*AgentBuilderAnswer, error) <span class="cov10" title="127">{
        data, err := t.r.ReadMessageLine()
        if err != nil &amp;&amp; !(err == io.EOF) </span><span class="cov0" title="0">{
                t.body.Close()
                return nil, fmt.Errorf("requestID=%s, err=%v", t.requestID, err)
        }</span>
        <span class="cov10" title="127">if err != nil &amp;&amp; err == io.EOF </span><span class="cov1" title="1">{
                t.body.Close()
                return nil, err
        }</span>
        <span class="cov10" title="127">if strings.HasPrefix(string(data), "data:") </span><span class="cov10" title="127">{
                var resp AgentBuilderRawResponse
                if err := json.Unmarshal(data[5:], &amp;resp); err != nil </span><span class="cov0" title="0">{
                        t.body.Close()
                        return nil, fmt.Errorf("requestID=%s, err=%v", t.requestID, err)
                }</span>
                <span class="cov10" title="127">answer := &amp;AgentBuilderAnswer{}
                answer.transform(&amp;resp)
                return answer, nil</span>
        }
        // 非SSE格式关闭连接，并返回数据
        <span class="cov0" title="0">t.body.Close()
        return nil, fmt.Errorf("requestID=%s, body=%s", t.requestID, string(data))</span>
}

// AgentBuilderOnceIterator 非流式返回时对应的迭代器，只可迭代一次
type AgentBuilderOnceIterator struct {
        body      io.ReadCloser
        requestID string
}

func (t *AgentBuilderOnceIterator) Next() (*AgentBuilderAnswer, error) <span class="cov0" title="0">{
        data, err := io.ReadAll(t.body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("requestID=%s, err=%v", t.requestID, err)
        }</span>
        <span class="cov0" title="0">defer t.body.Close()
        var resp AgentBuilderRawResponse
        if err := json.Unmarshal(data, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("requestID=%s, err=%v", t.requestID, err)
        }</span>
        <span class="cov0" title="0">answer := &amp;AgentBuilderAnswer{}
        answer.transform(&amp;resp)
        return answer, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright (c) 2024 Baidu, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package appbuilder

import (
        "bufio"
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "mime/multipart"
        "net/http"
        "net/url"
        "os"
        "path/filepath"
        "strconv"
        "time"
)

func GetAppList(req GetAppListRequest, config *SDKConfig) ([]App, error) <span class="cov1" title="1">{
        request := http.Request{}
        header := config.AuthHeaderV2()
        serviceURL, err := config.ServiceURLV2("/apps")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">request.URL = serviceURL
        request.Method = "GET"
        header.Set("Content-Type", "application/json")
        request.Header = header

        reqMap := make(map[string]any)
        reqJson, _ := json.Marshal(req)
        json.Unmarshal(reqJson, &amp;reqMap)
        params := url.Values{}
        for key, value := range reqMap </span><span class="cov10" title="3">{
                switch v := value.(type) </span>{
                case float64:<span class="cov1" title="1">
                        params.Add(key, strconv.Itoa(int(v)))</span>
                case string:<span class="cov6" title="2">
                        if v == "" </span><span class="cov6" title="2">{
                                continue</span>
                        }
                        <span class="cov0" title="0">params.Add(key, v)</span>
                }
        }
        <span class="cov1" title="1">serviceURL.RawQuery = params.Encode()

        config.BuildCurlCommand(&amp;request)
        client := config.HTTPClient
        if client == nil </span><span class="cov1" title="1">{
                client = &amp;http.Client{Timeout: 300 * time.Second}
        }</span>
        <span class="cov1" title="1">resp, err := client.Do(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">defer resp.Body.Close()
        requestID, err := checkHTTPResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">data, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">rsp := GetAppListResponse{}
        if err := json.Unmarshal(data, &amp;rsp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>

        <span class="cov1" title="1">return rsp.Data, nil</span>
}

func NewAppBuilderClient(appID string, config *SDKConfig) (*AppBuilderClient, error) <span class="cov1" title="1">{
        if appID == "" </span><span class="cov0" title="0">{
                return nil, errors.New("appID is empty")
        }</span>
        <span class="cov1" title="1">if config == nil </span><span class="cov0" title="0">{
                return nil, errors.New("config is nil")
        }</span>
        <span class="cov1" title="1">client := config.HTTPClient
        if client == nil </span><span class="cov1" title="1">{
                client = &amp;http.Client{Timeout: 300 * time.Second}
        }</span>
        <span class="cov1" title="1">return &amp;AppBuilderClient{appID: appID, sdkConfig: config, client: client}, nil</span>
}

type AppBuilderClient struct {
        appID     string
        sdkConfig *SDKConfig
        client    HTTPClient
}

// 在 AppBuilderClient 结构体中添加 Getter 方法
func (t *AppBuilderClient) GetSdkConfig() *SDKConfig <span class="cov0" title="0">{
        return t.sdkConfig
}</span>

func (t *AppBuilderClient) GetClient() HTTPClient <span class="cov0" title="0">{
        return t.client
}</span>

type HTTPClient interface {
        Do(req *http.Request) (*http.Response, error)
}

func (t *AppBuilderClient) CreateConversation() (string, error) <span class="cov1" title="1">{
        request := http.Request{}
        header := t.sdkConfig.AuthHeaderV2()
        serviceURL, err := t.sdkConfig.ServiceURLV2("/app/conversation")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">request.URL = serviceURL
        request.Method = "POST"
        header.Set("Content-Type", "application/json")
        request.Header = header
        req := map[string]string{"app_id": t.appID}
        data, _ := json.Marshal(req)
        request.Body = io.NopCloser(bytes.NewReader(data))
        t.sdkConfig.BuildCurlCommand(&amp;request)
        resp, err := t.client.Do(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">defer resp.Body.Close()
        requestID, err := checkHTTPResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">data, err = io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">rsp := make(map[string]any)
        if err := json.Unmarshal(data, &amp;rsp); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">val, ok := rsp["conversation_id"]
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("requestID=%s, body=%s", requestID, string(data))
        }</span>
        <span class="cov1" title="1">return val.(string), nil</span>
}

func (t *AppBuilderClient) UploadLocalFile(conversationID string, filePath string) (string, error) <span class="cov1" title="1">{
        var data bytes.Buffer
        w := multipart.NewWriter(&amp;data)
        appIDPart, _ := w.CreateFormField("app_id")
        appIDPart.Write([]byte(t.appID))
        conversationIDPart, _ := w.CreateFormField("conversation_id")
        conversationIDPart.Write([]byte(conversationID))
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">defer file.Close()
        filePart, _ := w.CreateFormFile("file", filepath.Base(filePath))
        if _, err := io.Copy(filePart, file); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">w.Close()
        request := http.Request{}
        serviceURL, err := t.sdkConfig.ServiceURLV2("/app/conversation/file/upload")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">request.URL = serviceURL
        request.Method = "POST"
        header := t.sdkConfig.AuthHeaderV2()
        header.Set("Content-Type", w.FormDataContentType())
        request.Header = header
        request.Body = NopCloser(bytes.NewReader(data.Bytes()))
        resp, err := t.client.Do(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">defer resp.Body.Close()
        requestID, err := checkHTTPResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">rsp := make(map[string]any)
        if err := json.Unmarshal(body, &amp;rsp); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">val, ok := rsp["id"]
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("requestID=%s, body=%s", requestID, string(body))
        }</span>
        <span class="cov1" title="1">return val.(string), nil</span>
}

func (t *AppBuilderClient) Run(conversationID string, query string, fileIDS []string, stream bool) (AppBuilderClientIterator, error) <span class="cov1" title="1">{
        if len(conversationID) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("conversationID mustn't be empty")
        }</span>
        <span class="cov1" title="1">m := map[string]any{
                "app_id":          t.appID,
                "conversation_id": conversationID,
                "query":           query,
                "file_ids":        fileIDS,
                "stream":          stream,
        }
        request := http.Request{}

        serviceURL, err := t.sdkConfig.ServiceURLV2("/app/conversation/runs")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">request.URL = serviceURL
        request.Method = "POST"
        header := t.sdkConfig.AuthHeaderV2()
        header.Set("Content-Type", "application/json")
        request.Header = header
        data, _ := json.Marshal(m)
        request.Body = NopCloser(bytes.NewReader(data))
        request.ContentLength = int64(len(data)) // 手动设置长度

        t.sdkConfig.BuildCurlCommand(&amp;request)

        resp, err := t.client.Do(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">requestID, err := checkHTTPResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">r := NewSSEReader(1024*1024, bufio.NewReader(resp.Body))
        if stream </span><span class="cov1" title="1">{
                return &amp;AppBuilderClientStreamIterator{requestID: requestID, r: r, body: resp.Body}, nil
        }</span>
        <span class="cov0" title="0">return &amp;AppBuilderClientOnceIterator{body: resp.Body}, nil</span>
}

func (t *AppBuilderClient) RunWithToolCall(req AppBuilderClientRunRequest) (AppBuilderClientIterator, error) <span class="cov10" title="3">{
        if len(req.ConversationID) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("conversationID mustn't be empty")
        }</span>

        <span class="cov10" title="3">request := http.Request{}

        serviceURL, err := t.sdkConfig.ServiceURLV2("/app/conversation/runs")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="3">header := t.sdkConfig.AuthHeaderV2()
        request.URL = serviceURL
        request.Method = "POST"
        header.Set("Content-Type", "application/json")
        request.Header = header
        data, _ := json.Marshal(req)
        request.Body = NopCloser(bytes.NewReader(data))
        request.ContentLength = int64(len(data)) // 手动设置长度

        t.sdkConfig.BuildCurlCommand(&amp;request)
        resp, err := t.client.Do(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="3">requestID, err := checkHTTPResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov10" title="3">r := NewSSEReader(1024*1024, bufio.NewReader(resp.Body))
        if req.Stream </span><span class="cov0" title="0">{
                return &amp;AppBuilderClientStreamIterator{requestID: requestID, r: r, body: resp.Body}, nil
        }</span>
        <span class="cov10" title="3">return &amp;AppBuilderClientOnceIterator{body: resp.Body}, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright (c) 2024 Baidu, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package appbuilder

import (
        "encoding/json"
        "fmt"
        "io"
        "reflect"
        "strings"
)

const (
        CodeContentType         = "code"
        TextContentType         = "text"
        ImageContentType        = "image"
        RAGContentType          = "rag"
        FunctionCallContentType = "function_call"
        AudioContentType        = "audio"
        VideoContentType        = "video"
        StatusContentType       = "status"
)

var TypeToStruct = map[string]reflect.Type{
        CodeContentType:         reflect.TypeOf(CodeDetail{}),
        TextContentType:         reflect.TypeOf(TextDetail{}),
        ImageContentType:        reflect.TypeOf(ImageDetail{}),
        RAGContentType:          reflect.TypeOf(RAGDetail{}),
        FunctionCallContentType: reflect.TypeOf(FunctionCallDetail{}),
        AudioContentType:        reflect.TypeOf(AudioDetail{}),
        VideoContentType:        reflect.TypeOf(VideoDetail{}),
        StatusContentType:       reflect.TypeOf(StatusDetail{}),
}

type AppBuilderClientRunRequest struct {
        AppID          string       `json:"app_id"`
        Query          string       `json:"query"`
        Stream         bool         `json:"stream"`
        EndUserID      *string      `json:"end_user_id"`
        ConversationID string       `json:"conversation_id"`
        Tools          []Tool       `json:"tools"`
        ToolOutputs    []ToolOutput `json:"tool_outputs"`
        ToolChoice     *ToolChoice  `json:"tool_choice"`
}

type Tool struct {
        Type     string   `json:"type"`
        Function Function `json:"function"`
}

type Function struct {
        Name        string         `json:"name"`
        Description string         `json:"description"`
        Parameters  map[string]any `json:"parameters"`
}

type ToolOutput struct {
        ToolCallID string `json:"tool_call_id" description:"工具调用ID"`
        Output     string `json:"output" description:"工具输出"`
}

type ToolChoice struct {
        Type     string             `json:"type"`
        Function ToolChoiceFunction `json:"function"`
}

type ToolChoiceFunction struct {
        Name  string                 `json:"name"`
        Input map[string]interface{} `json:"input"`
}

type AgentBuilderRawResponse struct {
        RequestID      string           `json:"request_id"`
        Date           string           `json:"date"`
        Answer         string           `json:"answer"`
        ConversationID string           `json:"conversation_id"`
        MessageID      string           `json:"message_id"`
        IsCompletion   bool             `json:"is_completion"`
        Content        []RawEventDetail `json:"content"`
}

type RawEventDetail struct {
        EventCode    int             `json:"event_code"`
        EventMessage string          `json:"event_message"`
        EventType    string          `json:"event_type"`
        EventID      string          `json:"event_id"`
        EventStatus  string          `json:"event_status"`
        ContentType  string          `json:"content_type"`
        Outputs      json.RawMessage `json:"outputs"`
        Usage        Usage           `json:"usage"`
        ToolCalls    []ToolCall      `json:"tool_calls"`
}

type Usage struct {
        PromptTokens     int    `json:"prompt_tokens"`
        CompletionTokens int    `json:"completion_tokens"`
        TotalTokens      int    `json:"total_tokens"`
        Name             string `json:"name"`
}

type AgentBuilderAnswer struct {
        Answer string
        Events []Event
}

type Event struct {
        Code        int
        Message     string
        Status      string
        EventType   string
        ContentType string
        Usage       Usage
        Detail      any // 将any替换为interface{}
        ToolCalls   []ToolCall
}

type ToolCall struct {
        ID       string             `json:"id"`       // 工具调用ID
        Type     string             `json:"type"`     // 需要输出的工具调用的类型。就目前而言，这始终是function
        Function FunctionCallOption `json:"function"` // 函数定义
}

type FunctionCallOption struct {
        Name      string         `json:"name"`
        Arguments map[string]any `json:"arguments"`
}

type TextDetail struct {
        Text string `json:"text"`
}

type CodeDetail struct {
        Text  string   `json:"text"`
        Code  string   `json:"code"`
        Files []string `json:"files"`
}

type RAGDetail struct {
        Text       string      `json:"text"`
        References []Reference `json:"references"`
}

type Reference struct {
        ID           string `json:"id"`
        From         string `json:"from"`
        URL          string `json:"url"`
        Content      string `json:"content"`
        SegmentID    string `json:"segment_id"`
        DocumentID   string `json:"document_id"`
        DatasetID    string `json:"dataset_id"`
        DocumentName string `json:"document_name"`
}

type FunctionCallDetail struct {
        Text  any    `json:"text"`
        Image string `json:"image"`
        Audio string `json:"audio"`
        Video string `json:"video"`
}

type ImageDetail struct {
        Image string `json:"image"`
}

type AudioDetail struct {
        Audio string `json:"audio"`
}

type VideoDetail struct {
        Video string `json:"video"`
}

type StatusDetail struct{}

type DefaultDetail struct {
        URLS  []string `json:"urls"`
        Files []string `json:"files"`
        Image string   `json:"image"`
        Video string   `json:"video"`
        Audio string   `json:"audio"`
}

type AppBuilderClientRawResponse struct {
        RequestID      string           `json:"request_id"`
        Date           string           `json:"date"`
        Answer         string           `json:"answer"`
        ConversationID string           `json:"conversation_id"`
        MessageID      string           `json:"message_id"`
        IsCompletion   bool             `json:"is_completion"`
        Content        []RawEventDetail `json:"content"`
}

type GetAppListRequest struct {
        Limit  int    `json:"limit"`
        After  string `json:"after"`
        Before string `json:"before"`
}

type GetAppListResponse struct {
        RequestID string `json:"request_id"`
        Data      []App  `json:"data"`
        Code      string `json:"code"`
        Message   string `json:"message"`
}

type App struct {
        ID          string `json:"id"`
        Name        string `json:"name"`
        Description string `json:"description"`
}

type AppBuilderClientAnswer struct {
        Answer string
        Events []Event
}

func (t *AppBuilderClientAnswer) transform(inp *AppBuilderClientRawResponse) <span class="cov10" title="111">{
        t.Answer = inp.Answer
        for _, c := range inp.Content </span><span class="cov10" title="111">{
                ev := Event{Code: c.EventCode,
                        Message:     c.EventMessage,
                        Status:      c.EventStatus,
                        EventType:   c.EventType,
                        ContentType: c.ContentType,
                        Usage:       c.Usage,
                        Detail:      c.Outputs,
                        ToolCalls:   c.ToolCalls}
                // 这部分新改的
                tp, ok := TypeToStruct[ev.ContentType]
                if !ok </span><span class="cov1" title="1">{
                        tp = reflect.TypeOf(DefaultDetail{})
                }</span>
                <span class="cov10" title="111">v := reflect.New(tp)
                _ = json.Unmarshal(c.Outputs, v.Interface())
                ev.Detail = v.Elem().Interface()
                // 这部分新改的
                t.Events = append(t.Events, ev)</span>
        }
}

// AppBuilderClientIterator 定义AppBuilderClient流式/非流式迭代器接口
// 初始状态可迭代,如果返回error不为空则代表迭代结束，
// error为io.EOF，则代表迭代正常结束，其它则为异常结束
type AppBuilderClientIterator interface {
        // Next 获取处理结果，如果返回error不为空，迭代器自动失效，不允许再调用此方法
        Next() (*AppBuilderClientAnswer, error)
}

type AppBuilderClientStreamIterator struct {
        requestID string
        r         *sseReader
        body      io.ReadCloser
}

func (t *AppBuilderClientStreamIterator) Next() (*AppBuilderClientAnswer, error) <span class="cov10" title="111">{
        data, err := t.r.ReadMessageLine()
        if err != nil &amp;&amp; !(err == io.EOF) </span><span class="cov0" title="0">{
                t.body.Close()
                return nil, fmt.Errorf("requestID=%s, err=%v", t.requestID, err)
        }</span>
        <span class="cov10" title="111">if err != nil &amp;&amp; err == io.EOF </span><span class="cov1" title="1">{
                t.body.Close()
                return nil, err
        }</span>
        <span class="cov10" title="111">if strings.HasPrefix(string(data), "data:") </span><span class="cov10" title="111">{
                var resp AppBuilderClientRawResponse
                if err := json.Unmarshal(data[5:], &amp;resp); err != nil </span><span class="cov0" title="0">{
                        t.body.Close()
                        return nil, fmt.Errorf("requestID=%s, err=%v", t.requestID, err)
                }</span>
                <span class="cov10" title="111">answer := &amp;AppBuilderClientAnswer{}
                answer.transform(&amp;resp)
                return answer, nil</span>
        }
        // 非SSE格式关闭连接，并返回数据
        <span class="cov0" title="0">t.body.Close()
        return nil, fmt.Errorf("requestID=%s, body=%s", t.requestID, string(data))</span>
}

// AppBuilderClientOnceIterator 非流式返回时对应的迭代器，只可迭代一次
type AppBuilderClientOnceIterator struct {
        body      io.ReadCloser
        requestID string
}

func (t *AppBuilderClientOnceIterator) Next() (*AppBuilderClientAnswer, error) <span class="cov4" title="6">{
        data, err := io.ReadAll(t.body)
        if err != nil </span><span class="cov3" title="3">{
                return nil, fmt.Errorf("requestID=%s, err=%v", t.requestID, err)
        }</span>
        <span class="cov3" title="3">defer t.body.Close()
        var resp AppBuilderClientRawResponse
        if err := json.Unmarshal(data, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("requestID=%s, err=%v", t.requestID, err)
        }</span>
        <span class="cov3" title="3">answer := &amp;AppBuilderClientAnswer{}
        answer.transform(&amp;resp)
        return answer, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright (c) 2024 Baidu, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package appbuilder

import (
        "fmt"
        "io"
        "log"
        "net/http"
        "net/url"
        "os"
        "path"
        "strings"

        "github.com/google/uuid"
)

const (
        GatewayURL            = "GATEWAY_URL"
        GatewayURLV2          = "GATEWAY_URL_V2"
        SecretKey             = "APPBUILDER_TOKEN"
        ConsoleOpenAPIVersion = "CONSOLE_OPENAPI_VERSION"
        ConsoleOpenAPIPrefix  = "CONSOLE_OPENAPI_PREFIX"
        SecretKeyPrefix       = "SECRET_KEY_PREFIX"
        DatasetID             = "DATASET_ID"
        SecretKeyV3           = "APPBUILDER_TOKEN_V3"
        DatasetIDV3           = "DATASET_ID_V3"
        DocumentIDV3          = "DOCUMENT_ID_V3"

        DefaultSecretKeyPrefix       = "Bearer"
        DefaultGatewayURL            = "https://appbuilder.baidu.com"
        DefaultGatewayURLV2          = "https://qianfan.baidubce.com"
        DefaultConsoleOpenAPIVersion = "/v2"
        DefaultConsoleOpenAPIPrefix  = ""
)

type SDKConfig struct {
        GatewayURL            string
        GatewayURLV2          string
        ConsoleOpenAPIVersion string
        ConsoleOpenAPIPrefix  string
        SecretKey             string
        HTTPClient            HTTPClient // custom HTTP Client, optional
        logger                *log.Logger
}

func NewSDKConfig(gatewayURL, secretKey string) (*SDKConfig, error) <span class="cov1" title="1">{
        gatewayURL = getEnvWithDefault(GatewayURL, gatewayURL, DefaultGatewayURL)
        gatewayURLV2 := getEnvWithDefault(GatewayURLV2, "", DefaultGatewayURLV2)
        openAPIVersion := getEnvWithDefault(ConsoleOpenAPIVersion, "", DefaultConsoleOpenAPIVersion)
        openAPIPrefix := getEnvWithDefault(ConsoleOpenAPIPrefix, "", DefaultConsoleOpenAPIPrefix)

        secretKey = getEnvWithDefault(SecretKey, secretKey, "")
        if len(secretKey) == 0 </span><span class="cov0" title="0">{
                log.Println("Error: secret key is empty")
        }</span>
        <span class="cov1" title="1">secretKeyPrefix := getEnvWithDefault(SecretKeyPrefix, "", DefaultSecretKeyPrefix)
        if !strings.HasPrefix(secretKey, secretKeyPrefix) </span><span class="cov1" title="1">{
                secretKey = secretKeyPrefix + " " + secretKey
        }</span>

        <span class="cov1" title="1">sdkConfig := &amp;SDKConfig{
                GatewayURL:            gatewayURL,
                GatewayURLV2:          gatewayURLV2,
                ConsoleOpenAPIVersion: openAPIVersion,
                ConsoleOpenAPIPrefix:  openAPIPrefix,
                SecretKey:             secretKey,
        }
        logFile := os.Getenv("APPBUILDER_LOGFILE")
        if len(logFile) &gt; 0 </span><span class="cov0" title="0">{
                f, err := os.OpenFile(logFile, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
                if err != nil </span><span class="cov0" title="0">{
                        sdkConfig.logger = log.New(os.Stdout, "", log.LstdFlags)
                }</span> else<span class="cov0" title="0"> {
                        sdkConfig.logger = log.New(f, "", log.LstdFlags)
                }</span>
        } else<span class="cov1" title="1"> {
                sdkConfig.logger = log.New(os.Stdout, "", log.LstdFlags)
        }</span>

        <span class="cov1" title="1">return sdkConfig, nil</span>
}

func getEnvWithDefault(key, paramValue, defaultValue string) string <span class="cov5" title="6">{
        if paramValue != "" </span><span class="cov1" title="1">{
                return paramValue
        }</span>

        <span class="cov6" title="7">v := os.Getenv(key)
        if v == "" </span><span class="cov5" title="5">{
                return defaultValue
        }</span>
        <span class="cov1" title="1">return v</span>
}

func (t *SDKConfig) AuthHeader() http.Header <span class="cov5" title="5">{
        header := t.authHeader()
        header.Set("X-Appbuilder-Authorization", t.SecretKey)
        t.logger.Printf("Auth Header %v", header)
        return header
}</span>

// AuthHeaderV2 适配OpenAPI，当前仅AgentBuilder使用
func (t *SDKConfig) AuthHeaderV2() http.Header <span class="cov6" title="7">{
        header := t.authHeader()
        header.Set("Authorization", t.SecretKey)
        t.logger.Printf("Auth Header %v", header)
        return header
}</span>

func (t *SDKConfig) authHeader() http.Header <span class="cov6" title="7">{
        header := make(http.Header)
        platform := os.Getenv("APPBUILDER_SDK_PLATFORM")
        if platform == "" </span><span class="cov6" title="7">{
                platform = "unknown"
        }</span>
        <span class="cov6" title="7">header.Set("X-Appbuilder-Origin", "appbuilder_sdk")
        header.Set("X-Appbuilder-Sdk-Config", "{\"appbuilder_sdk_version\":\"0.9.4\",\"appbuilder_sdk_language\":\"go\",\"appbuilder_sdk_platform\":\""+platform+"\"}")
        header.Set("X-Appbuilder-Request-Id", uuid.New().String())
        return header</span>
}

func (t *SDKConfig) ServiceURL(suffix string) (*url.URL, error) <span class="cov5" title="5">{
        // 解析 GatewayURL
        parsedURL, err := url.Parse(t.GatewayURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 使用 path.Join 拼接路径
        <span class="cov5" title="5">parsedURL.Path = path.Join(parsedURL.Path, suffix)

        // 将路径直接解析为最终 URL
        endpoint, err := url.Parse(suffix)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 解析相对路径
        <span class="cov5" title="5">parsedURL = parsedURL.ResolveReference(endpoint)

        // 返回拼接后的 URL
        return parsedURL, nil</span>
}

// ServiceURLV2 适配OpenAPI，当前仅AppbuilderClient使用
func (t *SDKConfig) ServiceURLV2(suffix string) (*url.URL, error) <span class="cov6" title="7">{
        suffix = path.Join(t.ConsoleOpenAPIPrefix, t.ConsoleOpenAPIVersion, suffix)
        return t.formatURL(t.GatewayURLV2, suffix)
}</span>

func (t *SDKConfig) formatURL(absolutePath, suffix string) (*url.URL, error) <span class="cov6" title="7">{
        t.logger.Printf("Service URL %s", absolutePath)
        url, err := url.Parse(absolutePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="7">endpoint, err := url.Parse(suffix)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="7">url = url.ResolveReference(endpoint)

        return url, nil</span>
}

type nopCloser struct {
        io.Reader
}

func (nopCloser) Close() error <span class="cov8" title="15">{ return nil }</span>

func NopCloser(r io.Reader) io.ReadCloser <span class="cov8" title="15">{
        return nopCloser{Reader: r}
}</span>

func (t *SDKConfig) BuildCurlCommand(req *http.Request) <span class="cov6" title="7">{
        curlCmd := fmt.Sprintf("curl -X %s -L '%v' \\\n", req.Method, req.URL.String())

        for k, v := range req.Header </span><span class="cov10" title="31">{
                header := fmt.Sprintf("-H '%v: %v' \\\n", k, v[0])
                curlCmd = fmt.Sprintf("%v %v", curlCmd, header)
        }</span>

        <span class="cov6" title="7">if req.Method == "POST" </span><span class="cov6" title="7">{
                bodyBytes, err := io.ReadAll(req.Body)
                if err != nil </span><span class="cov0" title="0">{
                        t.logger.Println("Failed to read request body:", err)
                        return
                }</span>
                <span class="cov6" title="7">req.Body.Close()
                req.Body = NopCloser(strings.NewReader(string(bodyBytes)))

                body := fmt.Sprintf("-d '%v'", string(bodyBytes))
                curlCmd = fmt.Sprintf("%v %v", curlCmd, body)</span>
        } else<span class="cov3" title="3"> if req.Method == "GET" || req.Method == "DELETE" </span><span class="cov3" title="3">{
                curlCmd = strings.TrimSuffix(curlCmd, " \\\n")
        }</span>
        <span class="cov6" title="7">fmt.Println("\n" + curlCmd + "\n")</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright (c) 2024 Baidu, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package appbuilder

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "mime/multipart"
        "net/http"
        "os"
        "path/filepath"
        "time"
)

// Deprecated: 已废弃，请使用 NewKnowledgeBase
func NewDataset(config *SDKConfig) (*Dataset, error) <span class="cov8" title="1">{
        if config == nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid config")
        }</span>
        <span class="cov8" title="1">client := config.HTTPClient
        if client == nil </span><span class="cov8" title="1">{
                client = &amp;http.Client{Timeout: 60 * time.Second}
        }</span>
        <span class="cov8" title="1">return &amp;Dataset{sdkConfig: config, client: client}, nil</span>
}

type Dataset struct {
        sdkConfig *SDKConfig
        client    HTTPClient
}

func (t *Dataset) Create(name string) (string, error) <span class="cov8" title="1">{
        request := http.Request{}
        header := t.sdkConfig.AuthHeader()
        serviceURL, err := t.sdkConfig.ServiceURL("/api/v1/ai_engine/agi_platform/v1/datasets/create")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">request.URL = serviceURL
        request.Method = "POST"
        header.Set("Content-Type", "application/json")
        request.Header = header
        req := map[string]string{"name": name}
        data, _ := json.Marshal(req)
        request.Body = NopCloser(bytes.NewReader(data))
        t.sdkConfig.BuildCurlCommand(&amp;request)
        resp, err := t.client.Do(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        requestID, err := checkHTTPResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov8" title="1">data, err = io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov8" title="1">rsp := DatasetResponse{}
        if err := json.Unmarshal(data, &amp;rsp); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov8" title="1">if rsp.Code != 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("requestID=%s, content=%v", requestID, string(data))
        }</span>
        <span class="cov8" title="1">return rsp.Result["id"].(string), nil</span>
}

func (t *Dataset) BatchUploadLocaleFile(datasetID string, localFilePaths []string) ([]string, error) <span class="cov0" title="0">{
        var fileIDs []string
        for _, localFilePath := range localFilePaths </span><span class="cov0" title="0">{
                fileID, err := t.uploadLocalFile(localFilePath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">fileIDs = append(fileIDs, fileID)</span>
        }
        <span class="cov0" title="0">documentIDS, err := t.addFileToDataset(datasetID, fileIDs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return documentIDS, nil</span>
}

func (t *Dataset) UploadLocalFile(datasetID string, localFilePath string) (string, error) <span class="cov8" title="1">{
        fileID, err := t.uploadLocalFile(localFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">documentIDs, err := t.addFileToDataset(datasetID, []string{fileID})
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("add file failed: %v", err)
        }</span>
        <span class="cov8" title="1">return documentIDs[0], nil</span>
}

func (t *Dataset) uploadLocalFile(localFilePath string) (string, error) <span class="cov8" title="1">{
        var data bytes.Buffer
        w := multipart.NewWriter(&amp;data)
        file, err := os.Open(localFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        filePart, _ := w.CreateFormFile("file", filepath.Base(file.Name()))
        if _, err := io.Copy(filePart, file); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">w.Close()

        request := http.Request{}
        header := t.sdkConfig.AuthHeader()
        serviceURL, err := t.sdkConfig.ServiceURL("/api/v1/ai_engine/agi_platform/v1/datasets/files/upload")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">request.URL = serviceURL
        request.Method = "POST"
        header.Set("Content-Type", w.FormDataContentType())
        request.Header = header
        request.Body = NopCloser(bytes.NewReader(data.Bytes()))
        resp, err := t.client.Do(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">requestID, err := checkHTTPResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov8" title="1">respData, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov8" title="1">rsp := DatasetResponse{}
        if err := json.Unmarshal(respData, &amp;rsp); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov8" title="1">if rsp.Code != 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("requestID=%s, content=%s", requestID, string(respData))
        }</span>
        <span class="cov8" title="1">fileID := rsp.Result["id"].(string)
        return fileID, nil</span>
}

func (t *Dataset) addFileToDataset(datasetID string, fileID []string) ([]string, error) <span class="cov8" title="1">{
        header := t.sdkConfig.AuthHeader()
        serviceURL, err := t.sdkConfig.ServiceURL("/api/v1/ai_engine/agi_platform/v1/datasets/documents")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">request := http.Request{}
        request.URL = serviceURL
        request.Method = "POST"
        header.Set("Content-Type", "application/json")
        request.Header = header
        m := map[string]any{
                "file_ids":   fileID,
                "dataset_id": datasetID}
        data, _ := json.Marshal(m)
        request.Body = NopCloser(bytes.NewReader(data))
        t.sdkConfig.BuildCurlCommand(&amp;request)
        resp, err := t.client.Do(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">requestID, err := checkHTTPResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov8" title="1">respData, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov8" title="1">rsp := DatasetBindResponse{}
        if err := json.Unmarshal(respData, &amp;rsp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov8" title="1">if rsp.Code != 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("requestID=%s, content=%s", requestID, string(respData))
        }</span>
        <span class="cov8" title="1">return rsp.Result.DocumentIDs, nil</span>
}

func (t *Dataset) ListDocument(datasetID string, page int, limit int, keyword string) (*ListDocumentResponse, error) <span class="cov8" title="1">{
        header := t.sdkConfig.AuthHeader()
        serviceURL, err := t.sdkConfig.ServiceURL("/api/v1/ai_engine/agi_platform/v1/datasets/documents/list_page")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">request := http.Request{}
        request.URL = serviceURL
        request.Method = "POST"
        header.Set("Content-Type", "application/json")
        request.Header = header
        m := map[string]any{
                "dataset_id": datasetID,
                "page":       page,
                "limit":      limit,
                "keyword":    keyword,
        }
        data, _ := json.Marshal(m)
        request.Body = NopCloser(bytes.NewReader(data))
        t.sdkConfig.BuildCurlCommand(&amp;request)
        resp, err := t.client.Do(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        requestID, err := checkHTTPResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov8" title="1">respData, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov8" title="1">rsp := ListDocumentResponse{}
        if err := json.Unmarshal(respData, &amp;rsp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov8" title="1">if rsp.Code != 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("requestID=%s, content=%s", requestID, string(respData))
        }</span>
        <span class="cov8" title="1">return &amp;rsp, nil</span>
}

func (t *Dataset) DeleteDocument(datasetID, documentID string) error <span class="cov8" title="1">{
        fmt.Println(datasetID, "  ", documentID)
        header := t.sdkConfig.AuthHeader()
        serviceURL, err := t.sdkConfig.ServiceURL("/api/v1/ai_engine/agi_platform/v1/datasets/document/delete")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">request := http.Request{}
        request.URL = serviceURL
        request.Method = "POST"
        header.Set("Content-Type", "application/json")
        request.Header = header
        m := map[string]string{
                "dataset_id":  datasetID,
                "document_id": documentID,
        }
        data, _ := json.Marshal(m)
        request.Body = NopCloser(bytes.NewReader(data))
        resp, err := http.DefaultClient.Do(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        requestID, err := checkHTTPResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright (c) 2024 Baidu, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package appbuilder

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "mime/multipart"
        "net/http"
        "net/url"
        "os"
        "path/filepath"
        "strconv"
        "time"

        "github.com/google/uuid"
)

func NewKnowledgeBase(config *SDKConfig) (*KnowledgeBase, error) <span class="cov1" title="1">{
        if config == nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid config")
        }</span>
        <span class="cov1" title="1">client := config.HTTPClient
        if client == nil </span><span class="cov1" title="1">{
                client = &amp;http.Client{Timeout: 60 * time.Second}
        }</span>
        <span class="cov1" title="1">return &amp;KnowledgeBase{sdkConfig: config, client: client}, nil</span>
}

type KnowledgeBase struct {
        sdkConfig *SDKConfig
        client    HTTPClient
}

func (t *KnowledgeBase) CreateDocument(req CreateDocumentRequest) (CreateDocumentResponse, error) <span class="cov1" title="1">{
        request := http.Request{}
        header := t.sdkConfig.AuthHeaderV2()
        if req.ClientToken == "" </span><span class="cov1" title="1">{
                req.ClientToken = uuid.New().String()
        }</span>

        <span class="cov1" title="1">serviceURL, err := t.sdkConfig.ServiceURLV2("/knowledge_base/document?clientToken=" + req.ClientToken)
        if err != nil </span><span class="cov0" title="0">{
                return CreateDocumentResponse{}, err
        }</span>
        <span class="cov1" title="1">request.URL = serviceURL
        request.Method = "POST"
        header.Set("Content-Type", "application/json")
        request.Header = header
        data, _ := json.Marshal(req)
        request.Body = NopCloser(bytes.NewReader(data))
        t.sdkConfig.BuildCurlCommand(&amp;request)
        resp, err := t.client.Do(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                return CreateDocumentResponse{}, err
        }</span>
        <span class="cov1" title="1">defer resp.Body.Close()
        requestID, err := checkHTTPResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                return CreateDocumentResponse{}, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">data, err = io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return CreateDocumentResponse{}, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">rsp := CreateDocumentResponse{}
        if err := json.Unmarshal(data, &amp;rsp); err != nil </span><span class="cov0" title="0">{
                return CreateDocumentResponse{}, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">if rsp.Code != "" </span><span class="cov0" title="0">{
                return CreateDocumentResponse{}, fmt.Errorf("requestID=%s, code=%s, message=%s", requestID, rsp.Code, rsp.Message)
        }</span>
        <span class="cov1" title="1">return rsp, nil</span>
}

func (t *KnowledgeBase) DeleteDocument(req DeleteDocumentRequest) error <span class="cov1" title="1">{
        header := t.sdkConfig.AuthHeaderV2()
        if req.ClientToken == "" </span><span class="cov1" title="1">{
                req.ClientToken = uuid.New().String()
        }</span>
        <span class="cov1" title="1">serviceURL, err := t.sdkConfig.ServiceURLV2("/knowledge_base/document?clientToken=" + req.ClientToken)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">reqMap := make(map[string]any)
        reqJson, _ := json.Marshal(req)
        json.Unmarshal(reqJson, &amp;reqMap)
        params := url.Values{}
        for key, value := range reqMap </span><span class="cov10" title="3">{
                switch v := value.(type) </span>{
                case float64:<span class="cov0" title="0">
                        params.Add(key, strconv.Itoa(int(v)))</span>
                case string:<span class="cov10" title="3">
                        if v == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov10" title="3">params.Add(key, v)</span>
                }
        }
        <span class="cov1" title="1">serviceURL.RawQuery = params.Encode()

        request := http.Request{}
        request.URL = serviceURL
        request.Method = "DELETE"
        header.Set("Content-Type", "application/json")
        request.Header = header
        t.sdkConfig.BuildCurlCommand(&amp;request)
        resp, err := http.DefaultClient.Do(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">defer resp.Body.Close()
        requestID, err := checkHTTPResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (t *KnowledgeBase) GetDocumentList(req GetDocumentListRequest) (*GetDocumentListResponse, error) <span class="cov1" title="1">{
        header := t.sdkConfig.AuthHeaderV2()
        serviceURL, err := t.sdkConfig.ServiceURLV2("/knowledge_base/documents")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">reqMap := make(map[string]any)
        reqJson, _ := json.Marshal(req)
        json.Unmarshal(reqJson, &amp;reqMap)
        params := url.Values{}
        for key, value := range reqMap </span><span class="cov1" title="1">{
                switch v := value.(type) </span>{
                case float64:<span class="cov0" title="0">
                        params.Add(key, strconv.Itoa(int(v)))</span>
                case string:<span class="cov1" title="1">
                        if v == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov1" title="1">params.Add(key, v)</span>
                }
        }
        <span class="cov1" title="1">serviceURL.RawQuery = params.Encode()

        request := http.Request{}
        request.URL = serviceURL
        request.Method = "GET"
        header.Set("Content-Type", "application/json")
        request.Header = header
        data, _ := json.Marshal(req)
        request.Body = NopCloser(bytes.NewReader(data))
        t.sdkConfig.BuildCurlCommand(&amp;request)
        resp, err := t.client.Do(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">defer resp.Body.Close()
        requestID, err := checkHTTPResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">respData, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">rsp := GetDocumentListResponse{}
        if err := json.Unmarshal(respData, &amp;rsp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">if rsp.Code != "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("requestID=%s, content=%s", requestID, string(respData))
        }</span>
        <span class="cov1" title="1">return &amp;rsp, nil</span>
}

func (t *KnowledgeBase) UploadFile(localFilePath string) (string, error) <span class="cov1" title="1">{
        var data bytes.Buffer
        w := multipart.NewWriter(&amp;data)
        file, err := os.Open(localFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">defer file.Close()
        filePart, _ := w.CreateFormFile("file", filepath.Base(file.Name()))
        if _, err := io.Copy(filePart, file); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">w.Close()

        request := http.Request{}
        header := t.sdkConfig.AuthHeaderV2()
        serviceURL, err := t.sdkConfig.ServiceURLV2("/file")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">request.URL = serviceURL
        request.Method = "POST"
        header.Set("Content-Type", w.FormDataContentType())
        request.Header = header
        request.Body = NopCloser(bytes.NewReader(data.Bytes()))
        resp, err := t.client.Do(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">requestID, err := checkHTTPResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">respData, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">rsp := UploadFileResponse{}
        if err := json.Unmarshal(respData, &amp;rsp); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">if rsp.Code != "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("requestID=%s, content=%s", requestID, string(respData))
        }</span>
        <span class="cov1" title="1">fileID := rsp.FileID
        return fileID, nil</span>
}

func (t *KnowledgeBase) CreateKnowledgeBase(req KnowledgeBaseDetail) (KnowledgeBaseDetail, error) <span class="cov1" title="1">{
        request := http.Request{}
        header := t.sdkConfig.AuthHeaderV2()
        if req.ClientToken == "" </span><span class="cov1" title="1">{
                req.ClientToken = uuid.New().String()
        }</span>
        <span class="cov1" title="1">serviceURL, err := t.sdkConfig.ServiceURLV2("/knowledgeBase?Action=CreateKnowledgeBase&amp;clientToken=" + req.ClientToken)
        if err != nil </span><span class="cov0" title="0">{
                return KnowledgeBaseDetail{}, err
        }</span>
        <span class="cov1" title="1">request.URL = serviceURL
        request.Method = "POST"
        header.Set("Content-Type", "application/json")
        request.Header = header
        data, _ := json.Marshal(req)
        request.Body = NopCloser(bytes.NewReader(data))
        t.sdkConfig.BuildCurlCommand(&amp;request)
        resp, err := t.client.Do(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                return KnowledgeBaseDetail{}, err
        }</span>
        <span class="cov1" title="1">defer resp.Body.Close()
        requestID, err := checkHTTPResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                return KnowledgeBaseDetail{}, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">data, err = io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return KnowledgeBaseDetail{}, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">rsp := KnowledgeBaseDetail{}
        if err := json.Unmarshal(data, &amp;rsp); err != nil </span><span class="cov0" title="0">{
                return KnowledgeBaseDetail{}, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>

        <span class="cov1" title="1">return rsp, nil</span>
}

func (t *KnowledgeBase) GetKnowledgeBaseDetail(knowledgeBaseID string) (KnowledgeBaseDetail, error) <span class="cov1" title="1">{
        request := http.Request{}
        header := t.sdkConfig.AuthHeaderV2()
        serviceURL, err := t.sdkConfig.ServiceURLV2("/knowledgeBase?Action=DescribeKnowledgeBase")
        if err != nil </span><span class="cov0" title="0">{
                return KnowledgeBaseDetail{}, err
        }</span>
        <span class="cov1" title="1">req := KnowledgeBaseDetail{}
        req.ID = knowledgeBaseID
        request.URL = serviceURL
        request.Method = "POST"
        header.Set("Content-Type", "application/json")
        request.Header = header
        data, _ := json.Marshal(req)
        request.Body = NopCloser(bytes.NewReader(data))
        t.sdkConfig.BuildCurlCommand(&amp;request)
        resp, err := t.client.Do(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                return KnowledgeBaseDetail{}, err
        }</span>
        <span class="cov1" title="1">defer resp.Body.Close()
        requestID, err := checkHTTPResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                return KnowledgeBaseDetail{}, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">data, err = io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return KnowledgeBaseDetail{}, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">rsp := KnowledgeBaseDetail{}
        if err := json.Unmarshal(data, &amp;rsp); err != nil </span><span class="cov0" title="0">{
                return KnowledgeBaseDetail{}, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>

        <span class="cov1" title="1">return rsp, nil</span>
}

func (t *KnowledgeBase) GetKnowledgeBaseList(req GetKnowledgeBaseListRequest) (GetKnowledgeBaseListResponse, error) <span class="cov1" title="1">{
        request := http.Request{}
        header := t.sdkConfig.AuthHeaderV2()
        serviceURL, err := t.sdkConfig.ServiceURLV2("/knowledgeBase?Action=DescribeKnowledgeBases")
        if err != nil </span><span class="cov0" title="0">{
                return GetKnowledgeBaseListResponse{}, err
        }</span>
        <span class="cov1" title="1">request.URL = serviceURL
        request.Method = "POST"
        header.Set("Content-Type", "application/json")
        request.Header = header
        data, _ := json.Marshal(req)
        request.Body = NopCloser(bytes.NewReader(data))
        t.sdkConfig.BuildCurlCommand(&amp;request)
        resp, err := t.client.Do(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                return GetKnowledgeBaseListResponse{}, err
        }</span>
        <span class="cov1" title="1">defer resp.Body.Close()
        requestID, err := checkHTTPResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                return GetKnowledgeBaseListResponse{}, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">data, err = io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return GetKnowledgeBaseListResponse{}, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">rsp := GetKnowledgeBaseListResponse{}
        if err := json.Unmarshal(data, &amp;rsp); err != nil </span><span class="cov0" title="0">{
                return GetKnowledgeBaseListResponse{}, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>

        <span class="cov1" title="1">return rsp, nil</span>
}

func (t *KnowledgeBase) ModifyKnowledgeBase(req ModifyKnowlegeBaseRequest) error <span class="cov1" title="1">{
        request := http.Request{}
        header := t.sdkConfig.AuthHeaderV2()
        if req.ClientToken == "" </span><span class="cov1" title="1">{
                req.ClientToken = uuid.New().String()
        }</span>
        <span class="cov1" title="1">serviceURL, err := t.sdkConfig.ServiceURLV2("/knowledgeBase?Action=ModifyKnowledgeBase&amp;clientToken=" + req.ClientToken)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">request.URL = serviceURL
        request.Method = "POST"
        header.Set("Content-Type", "application/json")
        request.Header = header
        data, _ := json.Marshal(req)
        request.Body = NopCloser(bytes.NewReader(data))
        t.sdkConfig.BuildCurlCommand(&amp;request)
        resp, err := t.client.Do(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">defer resp.Body.Close()
        requestID, err := checkHTTPResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">_, err = io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (t *KnowledgeBase) DeleteKnowledgeBase(knowledgeBaseID string) error <span class="cov1" title="1">{
        return t.deleteKnowledgeBase(knowledgeBaseID, "")
}</span>

func (t *KnowledgeBase) DeleteKnowledgeBaseWithReq(req DeleteKnowlegeBaseRequest) error <span class="cov0" title="0">{
        return t.deleteKnowledgeBase(req.ID, req.ClientToken)
}</span>

func (t *KnowledgeBase) deleteKnowledgeBase(knowledgeBaseID string, clientToken string) error <span class="cov1" title="1">{
        request := http.Request{}
        header := t.sdkConfig.AuthHeaderV2()
        if clientToken == "" </span><span class="cov1" title="1">{
                clientToken = uuid.New().String()
        }</span>
        <span class="cov1" title="1">serviceURL, err := t.sdkConfig.ServiceURLV2("/knowledgeBase?Action=DeleteKnowledgeBase&amp;clientToken=" + clientToken)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">req := KnowledgeBaseDetail{}
        req.ID = knowledgeBaseID
        request.URL = serviceURL
        request.Method = "POST"
        header.Set("Content-Type", "application/json")
        request.Header = header
        data, _ := json.Marshal(req)
        request.Body = NopCloser(bytes.NewReader(data))
        t.sdkConfig.BuildCurlCommand(&amp;request)
        resp, err := t.client.Do(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">defer resp.Body.Close()
        requestID, err := checkHTTPResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">_, err = io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (t *KnowledgeBase) CreateDocuments(req CreateDocumentsRequest) error <span class="cov1" title="1">{
        request := http.Request{}
        header := t.sdkConfig.AuthHeaderV2()
        if req.ClientToken == "" </span><span class="cov1" title="1">{
                req.ClientToken = uuid.New().String()
        }</span>
        <span class="cov1" title="1">serviceURL, err := t.sdkConfig.ServiceURLV2("/knowledgeBase?Action=CreateDocuments&amp;clientToken=" + req.ClientToken)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">request.URL = serviceURL
        request.Method = "POST"
        header.Set("Content-Type", "application/json")
        request.Header = header
        data, _ := json.Marshal(req)
        request.Body = NopCloser(bytes.NewReader(data))
        t.sdkConfig.BuildCurlCommand(&amp;request)
        resp, err := t.client.Do(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">defer resp.Body.Close()
        requestID, err := checkHTTPResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">_, err = io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (t *KnowledgeBase) UploadDocuments(localFilePath string, req CreateDocumentsRequest) error <span class="cov1" title="1">{
        var data bytes.Buffer
        w := multipart.NewWriter(&amp;data)
        file, err := os.Open(localFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">defer file.Close()
        filePart, _ := w.CreateFormFile("file", filepath.Base(file.Name()))
        if _, err := io.Copy(filePart, file); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">jsonData, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal request: %w", err)
        }</span>
        <span class="cov1" title="1">jsonPart, err := w.CreateFormField("payload")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create form field: %w", err)
        }</span>
        <span class="cov1" title="1">if _, err := jsonPart.Write(jsonData); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write JSON data: %w", err)
        }</span>
        <span class="cov1" title="1">w.Close()

        request := http.Request{}
        header := t.sdkConfig.AuthHeaderV2()
        if req.ClientToken == "" </span><span class="cov1" title="1">{
                req.ClientToken = uuid.New().String()
        }</span>
        <span class="cov1" title="1">serviceURL, err := t.sdkConfig.ServiceURLV2("/knowledgeBase?Action=UploadDocuments&amp;clientToken=" + req.ClientToken)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">request.URL = serviceURL
        request.Method = "POST"
        request.Header = header
        header.Set("Content-Type", w.FormDataContentType())
        request.Body = NopCloser(bytes.NewReader(data.Bytes()))
        resp, err := t.client.Do(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">defer resp.Body.Close()
        requestID, err := checkHTTPResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">_, err = io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (t *KnowledgeBase) CreateChunk(req CreateChunkRequest) (string, error) <span class="cov1" title="1">{
        request := http.Request{}
        header := t.sdkConfig.AuthHeaderV2()
        if req.ClientToken == "" </span><span class="cov1" title="1">{
                req.ClientToken = uuid.New().String()
        }</span>
        <span class="cov1" title="1">serviceURL, err := t.sdkConfig.ServiceURLV2("/knowledgeBase?Action=CreateChunk&amp;clientToken=" + req.ClientToken)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">request.URL = serviceURL
        request.Method = "POST"
        header.Set("Content-Type", "application/json")
        request.Header = header
        data, _ := json.Marshal(req)
        request.Body = NopCloser(bytes.NewReader(data))
        t.sdkConfig.BuildCurlCommand(&amp;request)
        resp, err := t.client.Do(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov1" title="1">defer resp.Body.Close()
        requestID, err := checkHTTPResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">data, err = io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>

        <span class="cov1" title="1">rsp := CreateChunkResponse{}
        if err := json.Unmarshal(data, &amp;rsp); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>

        <span class="cov1" title="1">return rsp.ID, nil</span>
}

func (t *KnowledgeBase) ModifyChunk(req ModifyChunkRequest) error <span class="cov1" title="1">{
        request := http.Request{}
        header := t.sdkConfig.AuthHeaderV2()
        if req.ClientToken == "" </span><span class="cov1" title="1">{
                req.ClientToken = uuid.New().String()
        }</span>
        <span class="cov1" title="1">serviceURL, err := t.sdkConfig.ServiceURLV2("/knowledgeBase?Action=ModifyChunk&amp;clientToken=" + req.ClientToken)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">request.URL = serviceURL
        request.Method = "POST"
        header.Set("Content-Type", "application/json")
        request.Header = header
        data, _ := json.Marshal(req)
        request.Body = NopCloser(bytes.NewReader(data))
        t.sdkConfig.BuildCurlCommand(&amp;request)
        resp, err := t.client.Do(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">defer resp.Body.Close()
        requestID, err := checkHTTPResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">data, err = io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>

        <span class="cov1" title="1">rsp := CreateChunkResponse{}
        if err := json.Unmarshal(data, &amp;rsp); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (t *KnowledgeBase) DeleteChunk(chunkID string) error <span class="cov1" title="1">{
        return t.deleteChunk(chunkID, "")
}</span>

func (t *KnowledgeBase) DeleteChunkWithReq(req DeleteChunkRequest) error <span class="cov0" title="0">{
        return t.deleteChunk(req.ChunkID, req.ClientToken)
}</span>

func (t *KnowledgeBase) deleteChunk(chunkID string, clientToken string) error <span class="cov1" title="1">{
        request := http.Request{}
        header := t.sdkConfig.AuthHeaderV2()
        if clientToken == "" </span><span class="cov1" title="1">{
                clientToken = uuid.New().String()
        }</span>
        <span class="cov1" title="1">serviceURL, err := t.sdkConfig.ServiceURLV2("/knowledgeBase?Action=DeleteChunk&amp;clientToken=" + clientToken)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">request.URL = serviceURL
        request.Method = "POST"
        header.Set("Content-Type", "application/json")
        request.Header = header
        req := DeleteChunkRequest{
                ChunkID: chunkID,
        }
        data, _ := json.Marshal(req)
        request.Body = NopCloser(bytes.NewReader(data))
        t.sdkConfig.BuildCurlCommand(&amp;request)
        resp, err := t.client.Do(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">defer resp.Body.Close()
        requestID, err := checkHTTPResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">data, err = io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>

        <span class="cov1" title="1">rsp := CreateChunkResponse{}
        if err := json.Unmarshal(data, &amp;rsp); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (t *KnowledgeBase) DescribeChunk(chunkID string) (DescribeChunkResponse, error) <span class="cov1" title="1">{
        request := http.Request{}
        header := t.sdkConfig.AuthHeaderV2()
        serviceURL, err := t.sdkConfig.ServiceURLV2("/knowledgeBase?Action=DescribeChunk")
        if err != nil </span><span class="cov0" title="0">{
                return DescribeChunkResponse{}, err
        }</span>
        <span class="cov1" title="1">request.URL = serviceURL
        request.Method = "POST"
        header.Set("Content-Type", "application/json")
        request.Header = header
        req := DescribeChunkRequest{
                ChunkID: chunkID,
        }
        data, _ := json.Marshal(req)
        request.Body = NopCloser(bytes.NewReader(data))
        t.sdkConfig.BuildCurlCommand(&amp;request)
        resp, err := t.client.Do(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                return DescribeChunkResponse{}, err
        }</span>
        <span class="cov1" title="1">defer resp.Body.Close()
        requestID, err := checkHTTPResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                return DescribeChunkResponse{}, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">data, err = io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return DescribeChunkResponse{}, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>

        <span class="cov1" title="1">rsp := DescribeChunkResponse{}
        if err := json.Unmarshal(data, &amp;rsp); err != nil </span><span class="cov0" title="0">{
                return DescribeChunkResponse{}, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>

        <span class="cov1" title="1">return rsp, nil</span>
}

func (t *KnowledgeBase) DescribeChunks(req DescribeChunksRequest) (DescribeChunksResponse, error) <span class="cov1" title="1">{
        request := http.Request{}
        header := t.sdkConfig.AuthHeaderV2()
        serviceURL, err := t.sdkConfig.ServiceURLV2("/knowledgeBase?Action=DescribeChunks")
        if err != nil </span><span class="cov0" title="0">{
                return DescribeChunksResponse{}, err
        }</span>
        <span class="cov1" title="1">request.URL = serviceURL
        request.Method = "POST"
        header.Set("Content-Type", "application/json")
        request.Header = header
        data, _ := json.Marshal(req)
        request.Body = NopCloser(bytes.NewReader(data))
        t.sdkConfig.BuildCurlCommand(&amp;request)
        resp, err := t.client.Do(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                return DescribeChunksResponse{}, err
        }</span>
        <span class="cov1" title="1">defer resp.Body.Close()
        requestID, err := checkHTTPResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                return DescribeChunksResponse{}, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov1" title="1">data, err = io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return DescribeChunksResponse{}, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>

        <span class="cov1" title="1">rsp := DescribeChunksResponse{}
        if err := json.Unmarshal(data, &amp;rsp); err != nil </span><span class="cov0" title="0">{
                return DescribeChunksResponse{}, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>

        <span class="cov1" title="1">return rsp, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright (c) 2024 Baidu, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package appbuilder

import (
        "bufio"
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "time"
)

func NewRAG(appID string, config *SDKConfig) (*RAG, error) <span class="cov0" title="0">{
        if len(appID) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("appID is empty")
        }</span>
        <span class="cov0" title="0">if config == nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid config")
        }</span>
        <span class="cov0" title="0">client := config.HTTPClient
        if client == nil </span><span class="cov0" title="0">{
                client = &amp;http.Client{Timeout: 500 * time.Second}
        }</span>
        <span class="cov0" title="0">return &amp;RAG{appID: appID, sdkConfig: config, client: client}, nil</span>
}

type RAG struct {
        appID     string
        sdkConfig *SDKConfig
        client    HTTPClient
}

func (t *RAG) Run(conversationID string, query string, stream bool) (RAGIterator, error) <span class="cov0" title="0">{
        request := http.Request{}
        header := t.sdkConfig.AuthHeader()
        serviceURL, err := t.sdkConfig.ServiceURL("/api/v1/ai_engine/agi_platform/v1/instance/integrated")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">request.URL = serviceURL
        request.Method = "POST"
        header.Set("Content-Type", "application/json")
        request.Header = header
        req := map[string]string{"conversation_id": conversationID,
                "response_mode": "blocking",
                "query":         query,
                "app_id":        t.appID,
        }
        if stream </span><span class="cov0" title="0">{
                req["response_mode"] = "streaming"
        }</span>
        <span class="cov0" title="0">data, _ := json.Marshal(req)
        request.Body = NopCloser(bytes.NewReader(data))
        t.sdkConfig.BuildCurlCommand(&amp;request)
        resp, err := t.client.Do(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">requestID, err := checkHTTPResponse(resp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("requestID=%s, err=%v", requestID, err)
        }</span>
        <span class="cov0" title="0">r := NewSSEReader(1024*1024, bufio.NewReader(resp.Body))
        if stream </span><span class="cov0" title="0">{
                return &amp;RAGStreamIterator{requestID: requestID, r: r, body: resp.Body}, nil
        }</span>
        <span class="cov0" title="0">return &amp;RAGOnceIterator{body: resp.Body, requestID: requestID}, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright (c) 2024 Baidu, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package appbuilder

import (
        "encoding/json"
        "fmt"
        "io"
        "strings"
)

type RAGRunResponse struct {
        Code    int       `json:"code"`
        Message string    `json:"message"`
        Result  RAGResult `json:"result"`
}

type RAGResult struct {
        ConversationID string     `json:"conversation_id"`
        Answer         string     `json:"answer"`
        Content        []RAGEvent `json:"content"`
}

type RAGEvent struct {
        Event       string          `json:"event"`
        EventStatus string          `json:"event_status"`
        EventID     string          `json:"event_id"`
        EventType   string          `json:"type"`
        Text        json.RawMessage `json:"text"`
}

type RAGAnswer struct {
        Answer         string
        ConversationID string
        Events         []RAGEvent
}

func (t *RAGAnswer) transform(res *RAGRunResponse) <span class="cov0" title="0">{
        t.Answer = res.Result.Answer
        t.ConversationID = res.Result.ConversationID
        t.Events = res.Result.Content
}</span>

// RAGIterator 定义RAG流式/非流式迭代器接口
// 初始状态可迭代,如果返回error不为空则代表迭代结束，
// error为io.EOF，则代表迭代正常结束，其它则为异常结束
type RAGIterator interface {
        // Next 获取处理结果，如果返回error不为空，迭代器自动失效，不允许再调用此方法
        Next() (*RAGAnswer, error)
}

type RAGStreamIterator struct {
        requestID string
        r         *sseReader
        body      io.ReadCloser
}

func (t *RAGStreamIterator) Next() (*RAGAnswer, error) <span class="cov0" title="0">{
        data, err := t.r.ReadMessageLine()
        if err != nil &amp;&amp; !(err == io.EOF) </span><span class="cov0" title="0">{
                t.body.Close()
                return nil, fmt.Errorf("requestID=%s, err=%v", t.requestID, err)
        }</span>
        <span class="cov0" title="0">if err != nil &amp;&amp; err == io.EOF </span><span class="cov0" title="0">{
                t.body.Close()
                return nil, err
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(string(data), "data:") </span><span class="cov0" title="0">{
                var resp RAGRunResponse
                resp.Code = -1
                if err := json.Unmarshal(data[5:], &amp;resp); err != nil </span><span class="cov0" title="0">{
                        t.body.Close()
                        return nil, fmt.Errorf("requestID=%s, err=%v", t.requestID, err)
                }</span>
                <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                        t.body.Close()
                        return nil, fmt.Errorf("requestID=%s, body=%s", t.requestID, string(data))
                }</span>
                <span class="cov0" title="0">answer := &amp;RAGAnswer{}
                answer.transform(&amp;resp)
                return answer, nil</span>
        }
        // 非SSE格式关闭连接，并返回数据
        <span class="cov0" title="0">t.body.Close()
        return nil, fmt.Errorf("requestID=%s, body=%s", t.requestID, string(data))</span>
}

// RAGOnceIterator 非流式返回时对应的迭代器，只可迭代一次
type RAGOnceIterator struct {
        body      io.ReadCloser
        eoi       bool
        requestID string
}

func (t *RAGOnceIterator) Next() (*RAGAnswer, error) <span class="cov0" title="0">{
        if t.eoi </span><span class="cov0" title="0">{
                return nil, io.EOF
        }</span>
        <span class="cov0" title="0">data, err := io.ReadAll(t.body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("requestID=%s, err=%v", t.requestID, err)
        }</span>
        <span class="cov0" title="0">defer t.body.Close()
        var resp RAGRunResponse
        resp.Code = -1
        if err := json.Unmarshal(data, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("requestID=%s, err=%v", t.requestID, err)
        }</span>
        <span class="cov0" title="0">if resp.Code != 0 </span><span class="cov0" title="0">{
                t.body.Close()
                return nil, fmt.Errorf("requestID=%s, body=%s", t.requestID, string(data))
        }</span>
        <span class="cov0" title="0">t.eoi = true
        answer := &amp;RAGAnswer{}
        answer.transform(&amp;resp)
        return answer, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright (c) 2024 Baidu, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package appbuilder

import (
        "bufio"
        "errors"
        "fmt"
        "io"
        "net/http"
)

type SSEEvent struct {
        LastEventID string
        Type        string
        Data        string
}

func checkHTTPResponse(rsp *http.Response) (string, error) <span class="cov4" title="7">{
        requestID := rsp.Header.Get("X-Appbuilder-Request-Id")
        if rsp.StatusCode == http.StatusOK </span><span class="cov4" title="7">{
                return requestID, nil
        }</span>

        <span class="cov0" title="0">data, err := io.ReadAll(rsp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return requestID, err
        }</span>
        <span class="cov0" title="0">return requestID, fmt.Errorf("http status code is %d, content is %s", rsp.StatusCode, string(data))</span>
}

func NewSSEReader(bufSize int, reader *bufio.Reader) *sseReader <span class="cov3" title="3">{
        buf := make([]byte, bufSize)
        return &amp;sseReader{reader: reader, buf: buf}
}</span>

type sseReader struct {
        reader *bufio.Reader
        buf    []byte
}

func (t *sseReader) ReadMessageLine() ([]byte, error) <span class="cov10" title="127">{
        size := 0
        for </span><span class="cov10" title="127">{
                line, isPrefix, err := t.reader.ReadLine()
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
                <span class="cov10" title="127">if len(line)+size &gt; cap(t.buf) </span><span class="cov0" title="0">{
                        panic("buffer overflow")</span>
                }
                <span class="cov10" title="127">size += copy(t.buf[size:], line)
                if !isPrefix </span><span class="cov10" title="127">{
                        break</span>
                }
        }
        // 读取空行
        <span class="cov10" title="127">line, _, err := t.reader.ReadLine()
        if err != nil || len(line) != 0 </span><span class="cov0" title="0">{
                size += copy(t.buf[size:], line)
                return nil, errors.New(string(t.buf[0:size]))
        }</span>
        <span class="cov10" title="127">return t.buf[0:size], nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
